---
title: Why Data Scientists aren't Doctors!
author: ~
date: '2017-07-17'
slug: second-new-post-in-r-markdown
categories: []
tags: []
---



<div id="intro" class="section level1">
<h1>Intro</h1>
<p>Technology is advancing at an unbelievable rate, and one of the most exciting, not to mention important, fields that is benefitting from this is the field of Medicine. From CAT scans to cancer cures, science and technology is making the impossible possible with treatments and procedures so advanced and effective, they almost border on the mythical. There are however some drawbacks. One of the most common ones that is joked around the proverbial water-cooler is self diagnosis using technology. In this day and age, if you tell someone that you’ve got a sore throat and feel a little under the weather, you’ll most likely be told “Don’t Google your symptoms, it’ll probably say you’re pregnant!”</p>
<p>As a prospective data scientist, I find this situation worrying, if not highly offensive… How is it possible that we aren’t able to accurately diagnose ourselves using the same advanced techniques that can effectively model the stock market, crime rates and pokemon cards?! And so, when the opportunity arose to find a data set, build a functional model and then use it to analyse said data set came up, I took it with both hands.</p>
<p>Full disclosure… I have included the entire code (except for the part about the packages needed), so if you are a BA major, you may want to look away now; if not, you should find it helpful should you want to do something similar.</p>
</div>
<div id="code-models-and-some-explanation" class="section level1">
<h1>Code, models and some explanation</h1>
<p>The first thing I had to do was to find some usable data. I settled on a set of just over 300 diagnoses of heart conditions, along with 13 possible factors sucg as age, max heart rate achieved under exercise and an ecg reading. These were factors that I expected to be highly correlated with heart conditions, and so expected a good model. If you are curious, you can find the data <a href="https://archive.ics.uci.edu/ml/machine-learning-databases/heart-disease/processed.cleveland.data">here</a>. The data is all numeric, so the heart diseases are ranked on a scale from 0 to 4, where 0 is completely healthy and 4 is an impending heart-attack.</p>
<p>If you check out that link, you will see that it just leads to a bunch of numbers on a screen. I therefore had to scrape the website and then format the data (a decent amount of work given my relative inexperience in the field), which was done with the code below. Of course, before doing even that, we have to import the necessary libraries, which are</p>
<p>library(rvest) library(stringr) library(dplyr) library(rpart) library(caret) library(vcdExtra) library(ipred) library(neuralnet) library(magrittr)</p>
<pre class="r"><code>#------------------------------Getting and processing our data----------------------------------------------
# Scrapes the data
raw_data &lt;- read_html(&quot;https://archive.ics.uci.edu/ml/machine-learning-databases/heart-disease/processed.cleveland.data&quot;) %&gt;%  #reads the the data from this page
  html_nodes(&quot;body&quot;) %&gt;%     
  html_text()

# Turns the data into a list 
no_n &lt;- gsub(&quot;\n&quot;, &quot; ,&quot;, raw_data)
row_data &lt;- strsplit(no_n, &quot;,&quot;)


data &lt;- data.frame(matrix(unlist(row_data), nrow=303, byrow=T))

colnames(data)[1] &lt;- &quot;Age&quot;
colnames(data)[2] &lt;- &quot;Sex&quot;
colnames(data)[3] &lt;- &quot;Chest_Pain&quot;
colnames(data)[4] &lt;- &quot;Blood_Pressure&quot;
colnames(data)[5] &lt;- &quot;Cholestoral&quot;
colnames(data)[6] &lt;- &quot;Blood_Sugar&quot;
colnames(data)[7] &lt;- &quot;ecg&quot;
colnames(data)[8] &lt;- &quot;Max_Heart_Rate&quot;
colnames(data)[9] &lt;- &quot;eia&quot;
colnames(data)[10] &lt;- &quot;Exercise_induced_feelings&quot;
colnames(data)[11] &lt;- &quot;Slope_of_ST&quot;
colnames(data)[12] &lt;- &quot;Fluoroscopy_stain&quot;
colnames(data)[13] &lt;- &quot;Thal&quot;
colnames(data)[14] &lt;- &quot;Diagnosis&quot;

#taking away all non useful cells
data[ data == &quot;?&quot; ] &lt;- NA
data &lt;- na.omit(data)


head(data)</code></pre>
<pre><code>##    Age Sex Chest_Pain Blood_Pressure Cholestoral Blood_Sugar ecg
## 1 63.0 1.0        1.0          145.0       233.0         1.0 2.0
## 2 67.0 1.0        4.0          160.0       286.0         0.0 2.0
## 3 67.0 1.0        4.0          120.0       229.0         0.0 2.0
## 4 37.0 1.0        3.0          130.0       250.0         0.0 0.0
## 5 41.0 0.0        2.0          130.0       204.0         0.0 2.0
## 6 56.0 1.0        2.0          120.0       236.0         0.0 0.0
##   Max_Heart_Rate eia Exercise_induced_feelings Slope_of_ST
## 1          150.0 0.0                       2.3         3.0
## 2          108.0 1.0                       1.5         2.0
## 3          129.0 1.0                       2.6         2.0
## 4          187.0 0.0                       3.5         3.0
## 5          172.0 0.0                       1.4         1.0
## 6          178.0 0.0                       0.8         1.0
##   Fluoroscopy_stain Thal Diagnosis
## 1               0.0  6.0        0 
## 2               3.0  3.0        2 
## 3               2.0  7.0        1 
## 4               0.0  3.0        0 
## 5               0.0  3.0        0 
## 6               0.0  3.0        0</code></pre>
<p>As you can see, the data comes out nicely in a data frame. Note that I have taken away all cells that contained “?” (there were a couple) as these would have messed up my models later.</p>
<p>The first thing I decided to was to model it using a decision tree, as this is a fairly simple model, but one that deals well with a large number of factors. To do this, we make use of the Caret package. This not only makes implementation easy, but also bootstraps the data 25 times and gives us a very nice output off results.</p>
<p>In order to implement the model, we first divide our data in testing and training parts. I have opted for a 75/25 split, but it doesn’t really matter as long as you have a split and the training set is in the significant majority. We do this so that we can realistically test our model. If you don’t see why this is necessary, think of it like this… imagine trying to teach a child basic maths. You want to teach him addition, so you tell him 2 + 2 = 4, 2 + 3 = 5 and so on. If you then go back and test him by asking him 2 +2, he should (hopefully) say the answer is 4. However, you can’t be sure if he has learnt addition, or if he just knows that 2 + 2 = 4. In order to test him, you ask a sum he hasn’t seen before, like 2 + 4. If he answers 6, you’re doing a good job… anything else, and not so much.</p>
<p>Back to the code. We then train our model with Diagnosis as a finction of everything (thats what ~ . means) and instruct it to use the rpart method, which is a decision tree. The next two lines just show us the details and decision tree for the model.</p>
<pre class="r"><code>#----------------------------------Training our model---------------------------------------------------

# Splitting the data into training and testing sets

index &lt;- sample(1:nrow(data),round(0.75*nrow(data)))

train &lt;- data[index,]
test &lt;- data[-index,]

# We then train our model using the training data set 
data.rpart &lt;- train(Diagnosis ~ ., data = train, method = &quot;rpart&quot;)
# We can look at the details of our model here
data.rpart</code></pre>
<pre><code>## CART 
## 
## 223 samples
##  13 predictor
##   5 classes: &#39;0 &#39;, &#39;1 &#39;, &#39;2 &#39;, &#39;3 &#39;, &#39;4 &#39; 
## 
## No pre-processing
## Resampling: Bootstrapped (25 reps) 
## Summary of sample sizes: 223, 223, 223, 223, 223, 223, ... 
## Resampling results across tuning parameters:
## 
##   cp          Accuracy   Kappa    
##   0.00990099  0.5546892  0.2778566
##   0.02475248  0.5642824  0.2772408
##   0.06930693  0.5659632  0.2313219
## 
## Accuracy was used to select the optimal model using  the largest value.
## The final value used for the model was cp = 0.06930693.</code></pre>
<pre class="r"><code># We can look at the decision tree here
data.rpart$finalModel</code></pre>
<pre><code>## n= 223 
## 
## node), split, n, loss, yval, (yprob)
##       * denotes terminal node
## 
## 1) root 223 101 0  (0.55 0.16 0.12 0.13 0.04) *</code></pre>
<pre class="r"><code>#--------------------------Testing the rpart model and looking at output---------------------------------

predict(data.rpart, test)</code></pre>
<pre><code>##  [1] 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 
## [24] 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 
## [47] 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 
## [70] 0  0  0  0  0 
## Levels: 0  1  2  3  4</code></pre>
<pre class="r"><code>confusionMatrix(predict(data.rpart, test), test$Diagnosis)</code></pre>
<pre><code>## Confusion Matrix and Statistics
## 
##           Reference
## Prediction 0  1  2  3  4 
##         0  38 18  9  5  4
##         1   0  0  0  0  0
##         2   0  0  0  0  0
##         3   0  0  0  0  0
##         4   0  0  0  0  0
## 
## Overall Statistics
##                                           
##                Accuracy : 0.5135          
##                  95% CI : (0.3944, 0.6315)
##     No Information Rate : 0.5135          
##     P-Value [Acc &gt; NIR] : 0.5466          
##                                           
##                   Kappa : 0               
##  Mcnemar&#39;s Test P-Value : NA              
## 
## Statistics by Class:
## 
##                      Class: 0  Class: 1  Class: 2  Class: 3  Class: 4 
## Sensitivity             1.0000    0.0000    0.0000   0.00000   0.00000
## Specificity             0.0000    1.0000    1.0000   1.00000   1.00000
## Pos Pred Value          0.5135       NaN       NaN       NaN       NaN
## Neg Pred Value             NaN    0.7568    0.8784   0.93243   0.94595
## Prevalence              0.5135    0.2432    0.1216   0.06757   0.05405
## Detection Rate          0.5135    0.0000    0.0000   0.00000   0.00000
## Detection Prevalence    1.0000    0.0000    0.0000   0.00000   0.00000
## Balanced Accuracy       0.5000    0.5000    0.5000   0.50000   0.50000</code></pre>
<p>Looking at the output of the code, we see that we have 223 samples for the training set, with 13 predictors and 5 classes. This all sounds good. One interesting aspect of the rpart model is that it is able to give us different complexity parameters and their subsequent accuracy is used in the model. The complexity parameter is effectively a measurement of how deep your decision tree is. If this doesn’t make sense, I suggest doing some background reading on it. We see that a complexity parameter of 0.028 gives us the highest level of accuracy, which is a worryingly low 53%. Not to worry however, as we haven’t tested the model yet. We can also have a look at the decision tree.</p>
<p>We then moving on to testing our model. We use the predict command, which predicts the Diagnosis of the 75 remaining data points using the 13 factors. We can see the output. This is nice to see, but really that useful. What is useful however, is the confusion matrix. This shows us how many false/true positive/negatives were produced by the model on the testing data set, as well as he overall statistics. We can see the sensitivity and specificity for each result, as well as the overall accuracy. Our accuracy is 59.46%, which is surprisingly low given what we expected.</p>
<p>A low accuracy value is not the end of the world, for several reasons. The first of these is we have chosen an inappropriate model for the data set. Following this thinking, I tried a different tact. I ran a logistical regression model for two reasons. The first is that it is another model and so we might have success in that regard. The second is that it is able to tell you which factors have a larger impact on the model, and it is possible that having extraneous factors in your model will make in inaccurate. And so, we took it for a spin.</p>
<p>Once again, we divide the data into testing and training sets. A subtlety here is that the logistic model strictly takes numeric arguments, so we have to make sure the dataframe is a numeric one. Onc again we train the model as Diagnosis as a function of everything with the training data set and then we have a look.</p>
<pre class="r"><code>#-----------------------------Using a Logistics model--------------------------------------------------

#We first turn the data into a numeric dataframe and get new training and testing sets
data &lt;- as.data.frame(sapply(data, as.numeric))
index &lt;- sample(1:nrow(data),round(0.75*nrow(data)))
train &lt;- data[index,]
test &lt;- data[-index,]


logistic &lt;- glm(Diagnosis ~ . , data = train)
summary(logistic)</code></pre>
<pre><code>## 
## Call:
## glm(formula = Diagnosis ~ ., data = train)
## 
## Deviance Residuals: 
##      Min        1Q    Median        3Q       Max  
## -2.44471  -0.54312  -0.07324   0.43167   2.73439  
## 
## Coefficients:
##                             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)               -1.8838280  0.4714950  -3.995 8.95e-05 ***
## Age                       -0.0030105  0.0073353  -0.410 0.681926    
## Sex                        0.2701683  0.1323493   2.041 0.042475 *  
## Chest_Pain                 0.2128826  0.0643597   3.308 0.001107 ** 
## Blood_Pressure            -0.0009431  0.0058152  -0.162 0.871316    
## Cholestoral               -0.0005588  0.0015066  -0.371 0.711105    
## Blood_Sugar               -0.1029197  0.1705757  -0.603 0.546919    
## ecg                        0.1074881  0.0586621   1.832 0.068326 .  
## Max_Heart_Rate            -0.0040413  0.0031305  -1.291 0.198151    
## eia                        0.3059850  0.1436423   2.130 0.034325 *  
## Exercise_induced_feelings  0.0214277  0.0070858   3.024 0.002807 ** 
## Slope_of_ST                0.2212926  0.1129189   1.960 0.051355 .  
## Fluoroscopy_stain          0.4539785  0.0686122   6.617 3.03e-10 ***
## Thal                       0.2604218  0.0736659   3.535 0.000502 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## (Dispersion parameter for gaussian family taken to be 0.695916)
## 
##     Null deviance: 355.55  on 222  degrees of freedom
## Residual deviance: 145.45  on 209  degrees of freedom
## AIC: 567.54
## 
## Number of Fisher Scoring iterations: 2</code></pre>
<pre class="r"><code>plot(logistic)</code></pre>
<p><img src="/post/Analysis_heart_conditions_files/figure-html/unnamed-chunk-4-1.png" width="672" /><img src="/post/Analysis_heart_conditions_files/figure-html/unnamed-chunk-4-2.png" width="672" /><img src="/post/Analysis_heart_conditions_files/figure-html/unnamed-chunk-4-3.png" width="672" /><img src="/post/Analysis_heart_conditions_files/figure-html/unnamed-chunk-4-4.png" width="672" /></p>
</div>
